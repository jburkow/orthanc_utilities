'''
Filename: orthanc_annotations.py
Author(s): Jonathan Burkow, burkowjo@msu.edu, Michigan State University
Last Updated: 11/10/2022
Description: Accesses remote Orthanc server to pull all annotations for every DICOM file. If not yet
    created, this will create a directory 'Annotation_Files' to store all annotation files and, for
    each day the script is run, it will create a sub-directory.
'''

import argparse
import json
import os
import sys
import time
from pathlib import Path
from typing import Dict, Tuple

import requests
from tqdm import tqdm

# Set the path to the rib_fracture_utils directory
FILE = Path(__file__).resolve()
ROOT = FILE.parents[1]
sys.path.append(str(ROOT))

from orthanc_load_server_info import get_orthanc_credentials
from args import ARGS


def parse_cmd_args():
    parser = argparse.ArgumentParser()

    parser.add_argument('--no_archive', action='store_true', help='Changes whether an additional folder for archiving annotations is made.')
    parser.add_argument('--clear_old', action='store_true', help='If true, first deletes all current annotation files in the base folder.')
    parser.add_argument('--break_loop', action='store_true', help='Condition to break the loop early after break_num iterations.')
    parser.add_argument('--break_num', type=int, default=5, help='Number of iterations to break loop after.')
    parser.add_argument('--credentials_file', type=str, help='Path to the file containing the server url, username, and password to connect to the Orthanc server.')

    return parser.parse_args()


def remove_old_annotations(folder: str) -> None:
    """
    Removes all JSON files from the provided directory.

    Parameters
    ----------
    folder : directory containing annotations files to clear
    """
    print('Removing old annotations...')
    filelist = [f for f in os.listdir(folder) if f.endswith(".json")]
    for f in filelist:
        os.remove(os.path.join(folder, f))


def create_anno_dict(anno_data: Dict[str, str]) -> Tuple[Dict[str, str], Dict[str, str]]:
    """
    Goes through the provided annotation information (in JSON format) and extract out relevant
    information, i.e. start/end points, text, and image resolution.

    Parameters
    ----------
    anno_data : JSON information from the annotation file for a specific type of annotation

    Returns
    -------
    anno_dict : extracted annotation information (start, end points and text, if applicable)
    reso_dict : height and width of the image containing the annotation
    """
    # Instantiate dictionary
    anno_dict = {}

    # Pull out resolution
    reso_dict = anno_data[0]['imageResolution']

    # Define lists
    start_list = []
    end_list = []
    text_list = []

    # Extract start points, end points, and text if present in annotation
    for annotation in anno_data:
        if 'start' in annotation['handles'].keys():
            x = annotation['handles']['start']['x']
            y = annotation['handles']['start']['y']
            start_list.append((x, y))
        if 'end' in annotation['handles'].keys():
            x = annotation['handles']['end']['x']
            y = annotation['handles']['end']['y']
            end_list.append((x, y))
        if 'text' in annotation.keys():
            text_list.append(annotation['text'])

    # Add lists to anno_dict (each if only runs if len > 0)
    if start_list:
        anno_dict['start_points'] = start_list
    if end_list:
        anno_dict['end_points'] = end_list
    if text_list:
        anno_dict['text'] = text_list

    return reso_dict, anno_dict


def extract_annotations(annotation_data: Dict[str, str], instance_uuid: str) -> Dict[str, str]:
    """
    Parses through the annotation data to extract all annotation
    information for the specific instance.

    Parameters
    ----------
    annotation_data : dictionary of all annotations associated with the study
    instance_uuid   : the unique ID generated by Orthanc for the specific instance

    Returns
    -------
    annotation_dictionary : dictionary containing all annotation information
    """
    # Initialize variables
    annotation_dictionary = {}
    instance = f'{instance_uuid}:0'

    # If the InstanceUUID is not in the keys, return None to move to next
    if instance not in annotation_data.keys():
        return None

    # Pull out individual annotation types
    if 'probe' in annotation_data[instance].keys():
        annotation_dictionary['image_resolution'], annotation_dictionary['points'] = create_anno_dict(annotation_data[instance]['probe']['data'])

    if 'arrowAnnotate' in annotation_data[instance].keys():
        annotation_dictionary['image_resolution'], annotation_dictionary['arrows'] = create_anno_dict(annotation_data[instance]['arrowAnnotate']['data'])

    if 'ellipticalRoi' in annotation_data[instance].keys():
        annotation_dictionary['image_resolution'], annotation_dictionary['ellipses'] = create_anno_dict(annotation_data[instance]['ellipticalRoi']['data'])

    if 'length' in annotation_data[instance].keys():
        annotation_dictionary['image_resolution'], annotation_dictionary['line_lengths'] = create_anno_dict(annotation_data[instance]['length']['data'])

    if 'rectangleRoi' in annotation_data[instance].keys():
        annotation_dictionary['image_resolution'], annotation_dictionary['rectangles'] = create_anno_dict(annotation_data[instance]['rectangleRoi']['data'])

    # Set boolean value for resolution (will be True if it pulled from above)
    resolution_bool = 'image_resolution' in annotation_dictionary

    return annotation_dictionary if resolution_bool else None


def main(parse_args: argparse.ArgumentParser) -> None:
    """Main Function"""

    parse_args = parse_cmd_args()

    # Define time string for archiving folders
    timestr = time.strftime("%Y%m%d")

    # Server connection information
    orthanc_server_url, credentials = get_orthanc_credentials(parse_args.credentials_file)

    # Use server connection details to set up URLs for each DICOM resource
    studies_url = orthanc_server_url + '/studies/'
    series_url = orthanc_server_url + '/series/'
    instances_url = orthanc_server_url + '/instances/'

    # Clear out current annotation files in base Annotation_Files folder
    if parse_args.clear_old:
        remove_old_annotations(ARGS['ANNOTATION_FOLDER'])

    # Loop through all studies and pull out annotation information
    print('Starting file creation...')
    files_created = 0
    all_studies = requests.get(studies_url, auth=credentials).json()
    for i, study in tqdm(enumerate(all_studies), desc='Processing studies', total=len(all_studies)):
        # Break after a certain number of images, if desired
        if parse_args.break_loop and i == parse_args.break_num:
            break

        # If the study has no annotation file, skip to next study
        if '9999' not in requests.get(studies_url + study + '/attachments/', auth=credentials).json():
            continue

        # Create the URL that will be used to retrieve annotation information
        annotation_url = studies_url + study + '/attachments/9999/data'

        study_info = requests.get(studies_url + study, auth=credentials).json()
        patient_id = study_info['PatientMainDicomTags']['PatientID'].replace(' ', '_')

        try:
            study_txt = study_info['MainDicomTags']['StudyDescription'].replace(' ', '_')
            if study_txt == '':
                study_txt = 'Study'
        except Exception:
            study_txt = 'Study'

        series_counter = 1
        for series in study_info['Series']:
            series_info = requests.get(series_url + series, auth=credentials).json()

            try:
                series_txt = series_info['MainDicomTags']['SeriesDescription'].replace(' ', '_')
                if series_txt == '':
                    series_txt = f'Series{str(series_counter)}'
                    series_counter += 1
            except Exception:
                try:
                    series_txt = 'Series' + series_info['MainDicomTags']['SeriesNumber']
                except Exception:
                    series_txt = f'Series{str(series_counter)}'
                    series_counter += 1

            for instance in series_info['Instances']:
                instance_info = requests.get(instances_url + instance, auth=credentials).json()
                instance_uid = instance_info['MainDicomTags']['SOPInstanceUID']
                pixel_spacing = requests.get(instances_url + instance + '/content/0028-0030', auth=credentials).text

                # Create the filename
                filename = '-'.join([patient_id, study_txt, series_txt, 'InstUID' + instance_uid[instance_uid.rfind('.')+1:], timestr]) + '.json'
                for char in ['/', '\\', ':', '*', '?', '\"', '<', '>', '|']:
                    filename = filename.replace(char, '-')

                # Obtain all annotation information
                total_dictionary = {'filename' : filename, 'patient_id' : patient_id, 'instance_uid' : instance_uid, 'pixel_spacing' : pixel_spacing.replace(' ', '')}
                annotation_data = requests.get(annotation_url, auth=credentials).json()
                annotations = extract_annotations(annotation_data, instance)
                # Check whether proper annotations were extracted
                if annotations is None:
                    continue
                total_dictionary |= annotations  # Same as total_dictionary.update(annotations)

                # Makes a folder of the date script is run
                if not os.path.isdir(os.path.join(ARGS['ANNOTATION_FOLDER'], f'{timestr}_Files')) and not parse_args.no_archive:
                    os.mkdir(os.path.join(ARGS['ANNOTATION_FOLDER'], f'{timestr}_Files'))
                    os.chmod(os.path.join(ARGS['ANNOTATION_FOLDER'], f'{timestr}_Files'), 0o777)

                # Dump annotation information into JSON file in proper directories
                if not parse_args.no_archive:
                    with open(os.path.join(ARGS['ANNOTATION_FOLDER'], f'{timestr}_Files', filename), 'w') as file:
                        json.dump(total_dictionary, file, sort_keys=False, indent=4)
                with open(os.path.join(ARGS['ANNOTATION_FOLDER'], filename), 'w') as file:
                    json.dump(total_dictionary, file, sort_keys=False, indent=4)
                files_created += 1

    print(f'Created {files_created} annotation files.')


if __name__ == "__main__":
    print('\nStarting execution...')
    start_time = time.perf_counter()
    main()
    elapsed = time.perf_counter() - start_time
    print('Done!')
    print(f'Execution finished in {elapsed:.3f} seconds ({time.strftime("%-H hr, %-M min, %-S sec", time.gmtime(elapsed))}).\n')
